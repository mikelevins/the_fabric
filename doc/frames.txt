The main Fabric programs are represented by classes that implement the
'frame' APIs defined in interface-frame.scm.

A frame is conceptually a dictionary, or an associative array. It maps
named keys to values. Using the traditional terminology of frame
languages, a single field in a frame is called a 'slot'.

Slots can have accessors: functions that are automatically called when
the slot is read or written. The frame interface ISlotAccessors
defines an API for defining accessors on slots.

There are two kinds of accessors: getters and setters. Their
signatures are as follows:

  getter: (lambda (frame slot-name) ...) => value
  setter: (lambda (frame slot-name value) ...) => value

To attach a getter to a slot, use set-slot-getter!

  (set-slot-getter! $my-frame foo: (lambda (frame slot-name) ...))

To attach a setter to a slot, use set-slot-setter!

  (set-slot-setter! $my-frame foo: (lambda (frame slot-name value) ...))

Note that these functions attach getters and setters to individual
slots on frame instances; they do not attach them to frame
classes. Different instances of a frame class can have different
getters and setters, and each individual slot can have its own getters
and setters.

It's also possible to arrange for all instances of a frame class to
share the same getters and setters, simply by setting them up in the
initialization code for the class.

Classes that inherit from the frame interfaces are frames. If a class
is defined as an implementation of ISlotAccessors then it's safe to
assume that it's intended to use setters and getters.

As an example, all of the application classes-- e.g. FabricApp,
FabricClient, and FabricWorkshop--implement ISlotAccessors. All of
these classes use getters and setters to configure and control their
runtime behavior.

As an example, setting the key focus-object: on an instance of
FabricWorkshop causes the application to change the object displayed
at the center of the scene. Setting the key skybox: causes it to
change the textures used to display the scene's skybox.

Getters also perform important services. For example, when you call

  (get $my-app settings:)

the expression returns an AppSettings object, but more than that, it
*ensures* that you will get back a properly-configured AppSettings
object because the getter on the slot settings: first checks whether
the slot already contains such an object. If not, it constructs and
initializes it, then stores it on the slot before returning it.

When you need to implement a data structure for use in the game that
requires nontrivial configuration, and especially if the configuration
may change during runtime, consider implementing it as a frame with
getters and setters.


